import { mkdir, readFile, stat, writeFile } from 'node:fs/promises';
import path from 'node:path';

export interface FindFirestoreIndexesJsonResult {
  indexesJsonPath: string;
  searchedPaths: string[];
}

async function fileExists(filePath: string): Promise<boolean> {
  try {
    const s = await stat(filePath);
    return s.isFile();
  } catch (err) {
    if (err && typeof err === 'object' && 'code' in err && (err as { code?: string }).code === 'ENOENT') {
      return false;
    }
    throw err;
  }
}

/**
 * Auto-locates `firestore.indexes.json` starting from `startDir` by searching:
 * - `<dir>/firestore.indexes.json`
 * - `<dir>/functions/firestore.indexes.json`
 * while walking up to the filesystem root.
 */
export async function findFirestoreIndexesJson(startDir: string): Promise<FindFirestoreIndexesJsonResult> {
  const searchedPaths: string[] = [];
  let dir = path.resolve(startDir);

  while (true) {
    const directCandidate = path.join(dir, 'firestore.indexes.json');
    searchedPaths.push(directCandidate);
    if (await fileExists(directCandidate)) {
      return { indexesJsonPath: directCandidate, searchedPaths };
    }

    const functionsCandidate = path.join(dir, 'functions', 'firestore.indexes.json');
    searchedPaths.push(functionsCandidate);
    if (await fileExists(functionsCandidate)) {
      return { indexesJsonPath: functionsCandidate, searchedPaths };
    }

    const parent = path.dirname(dir);
    if (parent === dir) {
      break;
    }
    dir = parent;
  }

  throw new Error(
    [
      'Unable to locate firestore.indexes.json.',
      'Searched:',
      ...searchedPaths.map((p) => `- ${p}`),
    ].join('\n')
  );
}

export interface GenerateFirestoreIndexesTsModuleOptions {
  /**
   * Working directory used for resolving `indexesJson` when it is a relative path
   * and for the auto-guess search root.
   */
  cwd?: string;

  /** Path to `firestore.indexes.json`. If omitted, it will be auto-guessed. */
  indexesJson?: string;

  /**
   * Output directory for generated files.
   * If a relative path is provided, it is resolved relative to the directory
   * containing `firestore.indexes.json`.
   *
   * Default: `src/generated` relative to `firestore.indexes.json` directory.
   */
  outputDir?: string;
}

export interface GenerateFirestoreIndexesTsModuleResult {
  indexesJsonPath: string;
  outputDir: string;
  outputFile: string;
}

function resolveOutputDir(outputDir: string | undefined, indexesJsonPath: string): string {
  const baseDir = path.dirname(indexesJsonPath);
  const defaultDir = path.join(baseDir, 'src', 'generated');

  if (!outputDir) {
    return defaultDir;
  }

  if (path.isAbsolute(outputDir)) {
    return outputDir;
  }

  return path.resolve(baseDir, outputDir);
}

function buildFirestoreIndexesTsModule(indexesJson: unknown, indexesJsonPath: string): string {
  const json = JSON.stringify(indexesJson, null, 2);

  return [
    '/* eslint-disable */',
    '/**',
    ' * AUTO-GENERATED FILE â€” DO NOT EDIT.',
    ' *',
    ` * Source: ${indexesJsonPath}`,
    ' * Generated by: flameql generate',
    ' */',
    '',
    `export const firestoreIndexes = ${json} as const;`,
    '',
    'export default firestoreIndexes;',
    '',
  ].join('\n');
}

export async function generateFirestoreIndexesTsModule(
  options: GenerateFirestoreIndexesTsModuleOptions = {}
): Promise<GenerateFirestoreIndexesTsModuleResult> {
  const cwd = options.cwd ?? process.cwd();

  const indexesJsonPath = options.indexesJson
    ? path.resolve(cwd, options.indexesJson)
    : (await findFirestoreIndexesJson(cwd)).indexesJsonPath;

  if (!await fileExists(indexesJsonPath)) {
    throw new Error(`Indexes JSON file does not exist: ${indexesJsonPath}`);
  }

  const outputDir = resolveOutputDir(options.outputDir, indexesJsonPath);
  const outputFile = path.join(outputDir, 'firestore-indexes.ts');

  const raw = await readFile(indexesJsonPath, 'utf8');
  const parsed = JSON.parse(raw) as unknown;

  await mkdir(outputDir, { recursive: true });
  await writeFile(outputFile, buildFirestoreIndexesTsModule(parsed, indexesJsonPath), 'utf8');

  return { indexesJsonPath, outputDir, outputFile };
}
